@tool
extends Node2D

## Path to the .dd2vtt file you want to import
@export_file("*.dd2vtt", "*.json", "*.txt") var source_file_path: String

## Click this checkbox in the Inspector to start the import process
@export var run_import: bool = false : set = _on_run_import_set

## Multiplier for light energy
@export var light_energy_scale: float = 1.0

## Collision layer for walls (default 1)
@export_flags_2d_physics var wall_collision_layer: int = 1

func _on_run_import_set(value):
	if value:
		if source_file_path == "":
			printerr("VTT Importer: No source file selected.")
		else:
			import_vtt(source_file_path)
	run_import = false

func import_vtt(path: String):
	print("VTT Importer: Starting import from ", path)
	
	# 1. Load File
	if not FileAccess.file_exists(path):
		printerr("VTT Importer: File not found.")
		return

	var file = FileAccess.open(path, FileAccess.READ)
	var content = file.get_as_text()
	var json = JSON.new()
	var error = json.parse(content)
	
	if error != OK:
		printerr("VTT Importer: JSON Parse Error on line ", json.get_error_line(), ": ", json.get_error_message())
		return
		
	var data = json.get_data()
	
	# Clear previous children generated by this script (optional cleanup)
	for child in get_children():
		child.queue_free()
	
	# 2. Setup Metrics
	var resolution = data.get("resolution", {})
	var pixels_per_grid = resolution.get("pixels_per_grid", 100)
	# map_origin is usually offset; typically 0,0 in dd2vtt but good to check
	var map_origin = Vector2(
		resolution.get("map_origin", {}).get("x", 0),
		resolution.get("map_origin", {}).get("y", 0)
	)
	
	# 3. Process Image (Base64)
	if data.has("image"):
		var image_node = _create_background_image(data["image"])
		add_child(image_node)
		# Set owner so it shows up in the scene tree after saving
		image_node.owner = get_tree().edited_scene_root
		print("VTT Importer: Background image created.")

	# 4. Process Walls (Line of Sight)
	if data.has("line_of_sight"):
		var walls_node = Node2D.new()
		walls_node.name = "Walls"
		add_child(walls_node)
		walls_node.owner = get_tree().edited_scene_root
		
		for loop in data["line_of_sight"]:
			var polygon_points = PackedVector2Array()
			for point in loop:
				var local_pos = (Vector2(point.x, point.y) - map_origin) * pixels_per_grid
				polygon_points.append(local_pos)
			
			_create_wall_collider(walls_node, polygon_points)
			_create_wall_occluder(walls_node, polygon_points)
			
		print("VTT Importer: Walls created.")

	# 5. Process Portals (Doors)
	if data.has("portals"):
		var portals_node = Node2D.new()
		portals_node.name = "Portals"
		add_child(portals_node)
		portals_node.owner = get_tree().edited_scene_root
		
		for portal in data["portals"]:
			_create_portal(portals_node, portal, map_origin, pixels_per_grid)
		print("VTT Importer: Portals created.")

	# 6. Process Lights
	if data.has("lights"):
		var lights_node = Node2D.new()
		lights_node.name = "Lights"
		add_child(lights_node)
		lights_node.owner = get_tree().edited_scene_root
		
		for light_data in data["lights"]:
			_create_light(lights_node, light_data, map_origin, pixels_per_grid)
		print("VTT Importer: Lights created.")
		
	print("VTT Importer: Import Complete.")

# --- Helper Functions ---

func _create_background_image(b64_string: String) -> Sprite2D:
	var img = Image.new()
	var error = img.load_jpg_from_buffer(Marshalls.base64_to_raw(b64_string))
	
	# Fallback to PNG if JPG fails (dd2vtt is usually JPG, but spec allows png)
	if error != OK:
		error = img.load_png_from_buffer(Marshalls.base64_to_raw(b64_string))
		
	if error != OK:
		printerr("VTT Importer: Failed to decode image buffer.")
		return null
		
	var tex = ImageTexture.create_from_image(img)
	var sprite = Sprite2D.new()
	sprite.texture = tex
	sprite.name = "MapBackground"
	sprite.centered = false # DD2VTT coordinates usually start 0,0 top-left
	return sprite

func _create_wall_collider(parent: Node, points: PackedVector2Array):
	var static_body = StaticBody2D.new()
	static_body.collision_layer = wall_collision_layer
	
	var col_poly = CollisionPolygon2D.new()
	col_poly.polygon = points
	
	static_body.add_child(col_poly)
	parent.add_child(static_body)
	
	static_body.owner = get_tree().edited_scene_root
	col_poly.owner = get_tree().edited_scene_root

func _create_wall_occluder(parent: Node, points: PackedVector2Array):
	var occluder = LightOccluder2D.new()
	var poly = OccluderPolygon2D.new()
	
	# Set polygon points
	poly.polygon = points
	poly.cull_mode = OccluderPolygon2D.CULL_DISABLED # Two-sided occlusion
	
	occluder.occluder = poly
	parent.add_child(occluder)
	occluder.owner = get_tree().edited_scene_root

func _create_portal(parent: Node, data: Dictionary, origin: Vector2, ppg: float):
	# Portals are often defined by a position and a bounds (start/end points)
	var bounds = data.get("bounds", [])
	if bounds.size() < 2: return
	
	var start = (Vector2(bounds[0].x, bounds[0].y) - origin) * ppg
	var end = (Vector2(bounds[1].x, bounds[1].y) - origin) * ppg
	
	# Create a simple static body for the door
	# Note: You might want to replace this with a custom "Door" scene in a real game
	var static_body = StaticBody2D.new()
	static_body.name = "Portal"
	
	var segment_shape = SegmentShape2D.new()
	segment_shape.a = start
	segment_shape.b = end
	
	var collision = CollisionShape2D.new()
	collision.shape = segment_shape
	
	# Check if closed
	if not data.get("closed", true):
		collision.disabled = true
		
	static_body.add_child(collision)
	parent.add_child(static_body)
	
	static_body.owner = get_tree().edited_scene_root
	collision.owner = get_tree().edited_scene_root

func _create_light(parent: Node, data: Dictionary, origin: Vector2, ppg: float):
	var light = PointLight2D.new()
	
	# Position
	var pos_data = data.get("position", {"x":0, "y":0})
	light.position = (Vector2(pos_data.x, pos_data.y) - origin) * ppg
	
	# Texture (Generate a gradient sphere)
	if not light.texture:
		var grad_tex = GradientTexture2D.new()
		grad_tex.width = 64
		grad_tex.height = 64
		grad_tex.fill = GradientTexture2D.FILL_RADIAL
		grad_tex.fill_from = Vector2(0.5, 0.5)
		grad_tex.fill_to = Vector2(0.5, 0.0) # Radius
		
		var grad = Gradient.new()
		# White center, transparent edge
		grad.set_color(0, Color(1, 1, 1, 1))
		grad.set_color(1, Color(1, 1, 1, 0))
		grad_tex.gradient = grad
		
		light.texture = grad_tex
	
	# Range & Scale
	# VTT "range" is usually grid units radius
	var range_val = data.get("range", 5.0)
	var pixel_radius = range_val * ppg
	# Our texture is 64x64, so radius is 32. Scale = pixel_radius / 32
	var tex_scale = pixel_radius / 32.0
	light.texture_scale = tex_scale
	
	# Color
	# dd2vtt color is often ARGB hex string (e.g. "ffFFE5BF")
	var hex_col = data.get("color", "ffffffff")
	if hex_col.length() == 8:
		# Godot expects RGBA or ARGB? Godot's Color.html() handles ARGB if it starts with #?
		# Actually Godot's `Color(hex_code)` expects RGBA usually.
		# Let's manually parse ARGB -> RGBA for Godot
		var a = hex_col.substr(0, 2)
		var r = hex_col.substr(2, 2)
		var g = hex_col.substr(4, 2)
		var b = hex_col.substr(6, 2)
		light.color = Color(r + g + b + a) # Reorder to RGBA string for safety
	
	# Intensity
	light.energy = data.get("intensity", 1.0) * light_energy_scale
	
	# Shadows
	light.shadow_enabled = data.get("shadows", false)
	
	parent.add_child(light)
	light.owner = get_tree().edited_scene_root
